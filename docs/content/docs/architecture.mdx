# Architecture

import { Callout } from 'nextra/components'
import { Steps } from 'nextra/components'
import { Tabs } from 'nextra/components'

Annota is a high-performance React annotation framework for digital pathology and whole slide imaging, designed to handle 10,000+ annotations at 60 FPS.

<Callout type="info">
**Key Innovation**: Annota separates framework-agnostic core logic from UI concerns, enabling use across different viewers and frameworks.
</Callout>

## Design Principles

<Steps>

### Separation of Concerns
Core annotation logic is independent of React and viewer implementations, enabling maximum reusability.

### Framework-Agnostic Core
The core engine works without React, allowing integration with vanilla JS, Vue, Svelte, or other frameworks.

### Type Safety
Full TypeScript with strict null checks ensures reliability and excellent developer experience.

### Performance First
WebGL rendering via PixiJS, R-tree spatial indexing, and viewport culling enable handling massive annotation datasets.

### Observable Pattern
Reactive state management allows efficient granular updates without re-rendering entire datasets.

</Steps>

## High-Level Architecture

```mermaid
graph TB
    subgraph React["React Layer"]
        Provider[AnnotaProvider]
        Hooks[Hooks API]
        Components[Components]
    end

    subgraph Adapter["Adapter Layer"]
        OSD[OpenSeadragon<br/>Annotator]
        Coords[Coordinate<br/>Transforms]
        Events[Event Handlers]
    end

    subgraph Rendering["Rendering Layer"]
        PixiStage[PixiJS Stage]
        Culling[Viewport Culling]
        Shapes[Shape Renderers]
    end

    subgraph Core["Core Layer"]
        Store[Annotation Store]
        Spatial[R-tree Index]
        History[History Manager]
        Layers[Layer Manager]
        Selection[Selection State]
    end

    React --> Adapter
    Adapter --> Rendering
    Adapter --> Core
    Rendering --> Core

    style React fill:#e1f5ff
    style Adapter fill:#fff4e6
    style Rendering fill:#f3e5f5
    style Core fill:#e8f5e9
```

## Architecture Layers

### Layer Responsibilities

```mermaid
graph LR
    A[User Interaction] --> B[React Components]
    B --> C[OSD Adapter]
    C --> D[Core State]
    D --> E[Observer Pattern]
    E --> F[Rendering Layer]
    F --> G[PixiJS WebGL]

    style A fill:#ffebee
    style D fill:#e8f5e9
    style G fill:#e3f2fd
```

<Tabs items={['React Layer', 'Adapter Layer', 'Rendering Layer', 'Core Layer']}>
  <Tabs.Tab>
    **React Layer** - User-facing API

    - `AnnotaProvider`: Context provider for dependency injection
    - **Hooks**: 20+ hooks for annotations, selection, tools, layers, history
    - **Components**: `AnnotaViewer`, `Annotator`, `AnnotationPopup`, `ContextMenu`
    - **Editors**: Shape-specific editors (PointEditor, RectangleEditor, PolygonEditor)

    The React layer is intentionally thin - it doesn't implement annotation logic, just provides React-friendly bindings.
  </Tabs.Tab>

  <Tabs.Tab>
    **Adapter Layer** - Viewer Integration

    - `OpenSeadragonAnnotator`: Main orchestrator class
    - **Coordinate transforms**: Image ↔ Viewport ↔ Screen space
    - **Event handling**: Mouse/touch events from OSD
    - **Lifecycle management**: Canvas creation, cleanup
    - **Hit detection**: Spatial queries for hover/click

    Adapters bridge the gap between viewer frameworks and the core engine.
  </Tabs.Tab>

  <Tabs.Tab>
    **Rendering Layer** - High-Performance Display

    - `PixiStage`: WebGL rendering via PixiJS v8
    - **Viewport culling**: Only render visible annotations
    - **Shape renderers**: Optimized per-shape-type rendering
    - **Style computation**: Evaluates static and dynamic styles
    - **Level-of-detail**: Simplification at low zoom levels

    Designed to handle 10,000+ annotations at 60 FPS.
  </Tabs.Tab>

  <Tabs.Tab>
    **Core Layer** - Framework-Agnostic Logic

    - `AnnotationStore`: CRUD operations with spatial indexing
    - `LayerManager`: Multi-layer support with visibility/opacity/locking
    - `History`: Undo/redo with command pattern
    - `SelectionManager`: Multi-selection state
    - `R-tree`: Spatial index for O(log n) queries

    All core logic is pure TypeScript with no framework dependencies.
  </Tabs.Tab>
</Tabs>

## Package Structure

```
lib/annota/
├── src/
│   ├── core/                    # Framework-agnostic core
│   │   ├── types.ts            # Annotation shapes & interfaces
│   │   ├── store.ts            # Observable annotation store
│   │   ├── spatial.ts          # R-tree spatial indexing
│   │   ├── layer.ts            # Multi-layer management
│   │   ├── history.ts          # Undo/redo command pattern
│   │   ├── selection.ts        # Selection state management
│   │   └── operations.ts       # Split/merge operations
│   │
│   ├── rendering/              # Rendering layer
│   │   └── pixi/
│   │       ├── stage.ts        # PixiJS stage lifecycle
│   │       ├── shapes.ts       # Shape-specific renderers
│   │       ├── styles.ts       # Style expression evaluation
│   │       └── culling.ts      # Viewport culling logic
│   │
│   ├── adapters/               # Viewer adapters
│   │   └── openseadragon/
│   │       ├── annotator.ts   # Main OSD annotator factory
│   │       ├── adapter.ts     # OSD integration
│   │       └── coordinates.ts # Coordinate transformations
│   │
│   ├── tools/                  # Annotation tools
│   │   ├── base.ts            # BaseTool abstract class
│   │   ├── point.ts           # PointTool
│   │   ├── rectangle.ts       # RectangleTool
│   │   ├── polygon.ts         # PolygonTool
│   │   ├── push.ts            # PushTool (vertex editing)
│   │   ├── split.ts           # SplitTool
│   │   └── contour.ts         # ContourTool (OpenCV.js)
│   │
│   ├── loaders/                # Format loaders
│   │   ├── h5.ts              # HDF5 loader (jsfive)
│   │   ├── pgm.ts             # PGM mask loader/saver
│   │   ├── masks.ts           # Binary mask to polygon conversion
│   │   └── json.ts            # JSON loader
│   │
│   └── react/                  # React integration
│       ├── Provider.tsx       # AnnotaProvider context
│       ├── Annotator.tsx      # Annotator component
│       ├── Viewer.tsx         # AnnotaViewer (OSD wrapper)
│       ├── popup/             # Popup system
│       ├── editors/           # Shape editors
│       └── hooks/             # 20+ React hooks
```

## Data Flow

### Annotation Lifecycle

```mermaid
sequenceDiagram
    participant User
    participant Tool
    participant Adapter
    participant Store
    participant Spatial
    participant Renderer

    User->>Tool: Click to create annotation
    Tool->>Adapter: Create annotation
    Adapter->>Store: store.add(annotation)
    Store->>Spatial: Index in R-tree
    Store->>Store: Notify observers
    Store-->>Renderer: Change event
    Renderer->>Renderer: Viewport culling
    Renderer->>Renderer: Render shapes
    Renderer-->>User: Visual feedback
```

### User Interaction Flow

```mermaid
graph TD
    A[User Click] --> B{Transform Coordinates}
    B --> C[Image Coordinates]
    C --> D[Spatial Query R-tree]
    D --> E{Hit Annotation?}
    E -->|Yes| F[Update Hover State]
    E -->|No| G[Clear Hover]
    F --> H[Notify Observers]
    G --> H
    H --> I[Renderer Update]
    I --> J[PixiJS Redraw]

    style A fill:#ffebee
    style D fill:#fff3e0
    style H fill:#e8f5e9
    style J fill:#e3f2fd
```

### State Management Flow

```mermaid
graph LR
    A[Store] --> B[Observer Pattern]
    B --> C[React Hooks]
    B --> D[Renderer]
    B --> E[Tools]

    F[History] --> A
    G[Layers] --> A
    H[Selection] --> B

    style A fill:#e8f5e9
    style B fill:#fff3e0
    style F fill:#f3e5f5
    style G fill:#f3e5f5
    style H fill:#f3e5f5
```

## Core Components

### 1. Annotation Store

<Callout type="info">
The store is the **single source of truth** for all annotation data, using the observable pattern for reactive updates.
</Callout>

```mermaid
classDiagram
    class AnnotationStore {
        -annotations Map
        -spatial RBush
        -observers Set
        +add(annotation)
        +update(id, updates)
        +delete(id)
        +get(id)
        +getAt(point)
        +getInBounds(bounds)
        +observe(callback)
    }

    class RBush {
        +insert(item)
        +remove(item)
        +search(bounds)
    }

    class Observer {
        <<interface>>
        +callback(event)
    }

    AnnotationStore --> RBush: uses
    AnnotationStore --> Observer: notifies
```

**Key Features**:
- **CRUD operations**: `add`, `update`, `delete`, `get`
- **Spatial queries**: `getAt(point)`, `getInBounds(bounds)` - O(log n) via R-tree
- **Observable**: Subscribe to changes with `observe(callback)`
- **Batch operations**: `addAll`, `updateAll`, `deleteAll` with single notification

### 2. Spatial Indexing

<Callout type="warning">
Without spatial indexing, finding annotations under cursor would be O(n). With R-tree, it's O(log n).
</Callout>

**Performance Impact**:
- 10,000 annotations: Linear search ~10,000 checks → R-tree ~13 checks
- Enables real-time hover feedback even with massive datasets

### 3. Layer System

```mermaid
graph TB
    subgraph LayerManager
        L1[tumor: visible=true]
        L2[stroma: visible=false]
        L3[background: locked=true]
    end

    Store --> LayerManager
    LayerManager --> Filter[Layer Filter]
    Filter --> Renderer

    style L1 fill:#ffcdd2
    style L2 fill:#c8e6c9
    style L3 fill:#bbdefb
```

Each layer has:
- **Visibility**: Show/hide all annotations on layer
- **Opacity**: Control transparency (0-1)
- **Lock**: Prevent editing
- **Filter**: Custom filter function (e.g., mask polarity)

### 4. History System

```mermaid
graph LR
    A[Command Pattern] --> B[CreateCommand]
    A --> C[UpdateCommand]
    A --> D[DeleteCommand]
    A --> E[BatchCommand]
    A --> F[SplitCommand]
    A --> G[MergeCommand]

    B --> H[History Manager]
    C --> H
    D --> H
    E --> H
    F --> H
    G --> H

    H --> I[Undo Stack]
    H --> J[Redo Stack]

    style A fill:#e8f5e9
    style H fill:#fff3e0
```

**Supports**:
- All CRUD operations
- Split/merge operations
- Batch operations (single undo step)
- Configurable history depth

## Rendering Pipeline

```mermaid
graph TD
    A[Viewport Change] --> B[Compute Visible Bounds]
    B --> C[Spatial Query R-tree]
    C --> D[Culled Annotation Set]
    D --> E{For Each Annotation}
    E --> F[Compute Style]
    F --> G{Shape Type}
    G -->|Point| H[Render Point]
    G -->|Rectangle| I[Render Rectangle]
    G -->|Polygon| J[Render Polygon]
    G -->|Circle| K[Render Circle]
    H --> L[PixiJS Graphics]
    I --> L
    J --> L
    K --> L
    L --> M[WebGL Output]

    style A fill:#e3f2fd
    style C fill:#fff3e0
    style F fill:#f3e5f5
    style M fill:#e8f5e9
```

### Performance Optimizations

1. **Viewport Culling**: Only render annotations in visible area
2. **Spatial Indexing**: Fast O(log n) bounds queries
3. **WebGL Acceleration**: Hardware-accelerated rendering via PixiJS
4. **Style Caching**: Reuse computed styles when possible
5. **Debounced Updates**: Batch viewport changes

## Coordinate Systems

<Callout type="warning">
Understanding coordinate systems is critical for working with Annota and OpenSeadragon.
</Callout>

```mermaid
graph LR
    A[Image Space<br/>Native pixels] <-->|viewport.imageToViewerElementCoordinates| B[Screen Space<br/>Browser pixels]
    A <-->|viewport.viewportToImageCoordinates| C[Viewport Space<br/>Normalized 0-1]
    B <-->|viewport.viewerElementToViewportCoordinates| C

    style A fill:#ffebee
    style B fill:#e3f2fd
    style C fill:#f3e5f5
```

### Coordinate Spaces

<Tabs items={['Image Space', 'Viewport Space', 'Screen Space']}>
  <Tabs.Tab>
    **Image Space** - Native pixel coordinates

    - Origin: Top-left of image (0, 0)
    - Units: Image pixels
    - **This is what's stored in annotations**
    - Independent of zoom/pan

    Example: A 10,000 × 10,000 pixel image uses coordinates like (5000, 5000)
  </Tabs.Tab>

  <Tabs.Tab>
    **Viewport Space** - Normalized coordinates

    - Origin: Top-left of viewport
    - Units: Normalized (typically 0-1 range)
    - Changes with zoom/pan
    - OpenSeadragon's internal coordinate system

    Used for viewport calculations but rarely in application code.
  </Tabs.Tab>

  <Tabs.Tab>
    **Screen Space** - Browser pixel coordinates

    - Origin: Top-left of viewer container
    - Units: CSS pixels
    - Where mouse events occur
    - Must transform to image space for annotation operations

    Example: `pointerEventToImage(event)` converts click to image coordinates
  </Tabs.Tab>
</Tabs>

## Type System

### Core Annotation Types

```typescript
interface Annotation {
  id: string;                          // Unique identifier
  shape: Shape;                        // Geometry definition
  properties?: Record<string, any>;    // Custom metadata
  style?: AnnotationStyle;             // Visual appearance
  layerId?: string;                    // Layer assignment
  maskPolarity?: 'positive' | 'negative';  // For mask-based workflows
}

type Shape =
  | PointShape
  | RectangleShape
  | PolygonShape
  | MultiPolygonShape
  | CircleShape
  | EllipseShape
  | LineShape
  | FreehandShape;
```

### Shape Definitions

```mermaid
classDiagram
    class Shape {
        <<interface>>
        +type: string
        +bounds: Bounds
    }

    class PointShape {
        +type: "point"
        +x: number
        +y: number
    }

    class RectangleShape {
        +type: "rectangle"
        +x: number
        +y: number
        +width: number
        +height: number
    }

    class PolygonShape {
        +type: "polygon"
        +points: Point[]
    }

    class MultiPolygonShape {
        +type: "multipolygon"
        +polygons: Point[][]
    }

    Shape <|-- PointShape
    Shape <|-- RectangleShape
    Shape <|-- PolygonShape
    Shape <|-- MultiPolygonShape
```

### Style Expression System

Annota supports both static and dynamic styling:

```typescript
// Static style - same for all annotations
const staticStyle: AnnotationStyle = {
  fill: '#FF0000',
  fillOpacity: 0.3,
  stroke: '#FFFFFF',
  strokeWidth: 2,
};

// Dynamic style - computed per annotation
const dynamicStyle: StyleExpression = (annotation, state) => ({
  fill: annotation.properties?.type === 'tumor' ? '#FF0000' : '#00FF00',
  fillOpacity: state.hover ? 0.6 : 0.3,
  stroke: state.selected ? '#FFFF00' : '#FFFFFF',
  strokeWidth: state.selected ? 4 : 2,
});
```

## Tool System

```mermaid
classDiagram
    class BaseTool {
        <<abstract>>
        +enabled: boolean
        +init(viewer, annotator)
        +onCanvasPress(event)
        +onCanvasDrag(event)
        +onCanvasRelease(event)
        +onCanvasClick(event)
        +destroy()
    }

    class PointTool {
        +onCanvasClick(event)
        -createPoint()
    }

    class RectangleTool {
        -startPoint: Point
        +onCanvasPress(event)
        +onCanvasDrag(event)
        +onCanvasRelease(event)
    }

    class PolygonTool {
        -vertices: Point[]
        +onCanvasClick(event)
        +onKeyDown(event)
        -completePolygon()
    }

    class SplitTool {
        -splitLine: Point[]
        -targetAnnotation: Annotation
        +onCanvasClick(event)
        -executeSplit()
    }

    BaseTool <|-- PointTool
    BaseTool <|-- RectangleTool
    BaseTool <|-- PolygonTool
    BaseTool <|-- SplitTool
```

### Tool Lifecycle

```mermaid
sequenceDiagram
    participant User
    participant useTool Hook
    participant BaseTool
    participant Viewer
    participant Store

    User->>useTool Hook: Enable tool
    useTool Hook->>BaseTool: init(viewer, annotator)
    BaseTool->>Viewer: Register event handlers

    User->>Viewer: Mouse interaction
    Viewer->>BaseTool: Event callback
    BaseTool->>Store: Create/update annotation
    Store-->>BaseTool: Confirmation

    User->>useTool Hook: Disable tool
    useTool Hook->>BaseTool: destroy()
    BaseTool->>Viewer: Unregister handlers
```

## Inspired by Annotorious

Annota's architecture incorporates lessons from [Annotorious v3](https://annotorious.dev):

### 1. Multi-Layer Rendering

<Callout type="info">
Instead of a monolithic overlay, separate concerns into specialized layers.
</Callout>

- **PixiLayer**: Display layer using WebGL for performance
- **SVGDrawingLayer**: Interactive drawing tools with precise vector control
- **SVGSelectionLayer**: Selection highlighting and handles

### 2. Observable State Pattern

```typescript
const state = {
  store: createStore<Annotation>(),      // Annotation data
  hover: createHoverState(),             // Hover tracking
  selection: createSelectionState(),     // Selection tracking
  viewport: createViewportState(),       // Viewport state
};
```

**Key Insight**: Layers observe and react to state changes - they don't manage state themselves.

### 3. Thin React Wrapper

The React layer doesn't implement annotation logic - it's purely a bridge:

```tsx
// React just provides convenient access
function MyComponent() {
  const annotations = useAnnotations();  // Observes store
  const annotator = useAnnotator();      // Access to core API

  // Core logic lives in annotator, not React
  return <button onClick={() => annotator.addAnnotation(...)}>Add</button>;
}
```

## Extension Points

<Steps>

### Custom Loaders
Implement the loader interface to support new annotation formats:

```typescript
interface AnnotationLoader {
  load(source: any): Promise<Annotation[]>;
  save(annotations: Annotation[]): Promise<Blob>;
}
```

### Custom Renderers
Replace PixiJS with Canvas2D, SVG, or other rendering backends by implementing the renderer interface.

### Custom Adapters
Support other viewers (Leaflet, OpenLayers, custom WebGL viewers) by creating an adapter.

### Custom Tools
Extend `BaseTool` to create new annotation interaction patterns.

### Styling Functions
Implement dynamic styling based on annotation properties, external state, or user preferences.

</Steps>

## Performance Benchmarks

<Callout type="success">
Annota is designed to handle **10,000+ annotations at 60 FPS** on modern hardware.
</Callout>

| Operation | Without Optimization | With Optimization |
|-----------|---------------------|-------------------|
| Hover detection (10k annotations) | ~10ms (100 FPS) | ~0.1ms (10000 FPS) |
| Render all (10k annotations) | ~50ms (20 FPS) | ~8ms (120 FPS) |
| Viewport pan/zoom | Laggy | Smooth 60 FPS |

**Key Optimizations**:
1. R-tree spatial indexing: O(n) → O(log n) for spatial queries
2. Viewport culling: Render ~100 visible instead of 10,000 total
3. WebGL rendering: Hardware acceleration via PixiJS
4. Observable pattern: Granular updates, no full re-renders

## Best Practices

### 1. Use Spatial Queries

```typescript
// ❌ Bad - iterates all annotations
const annotations = annotator.getAnnotations();
const nearby = annotations.filter(ann => isNear(point, ann));

// ✅ Good - uses R-tree spatial index
const nearby = annotator.getAnnotationsAt(point, radius);
```

### 2. Batch Operations

```typescript
// ❌ Bad - triggers N observer notifications
annotations.forEach(ann => store.add(ann));

// ✅ Good - triggers 1 observer notification
store.addAll(annotations);
```

### 3. Layer Organization

```typescript
// ✅ Organize by semantic meaning
const layers = {
  tumor: { visible: true, opacity: 0.5 },
  stroma: { visible: true, opacity: 0.3 },
  background: { visible: false },
  annotations: { visible: true, locked: false },
};
```

### 4. Style Performance

```typescript
// ❌ Bad - complex computation on every render
const style = (ann) => {
  const result = heavyComputation(ann.properties);
  return { fill: result.color };
};

// ✅ Good - compute once, memoize if needed
const colorMap = computeColorMap(annotations);
const style = (ann) => ({ fill: colorMap[ann.id] });
```

## Public API Surface

```typescript
// Core - Framework-agnostic
export { createAnnotationStore, createLayerManager, createHistory } from './core';
export type { Annotation, AnnotationStyle, Shape } from './core/types';

// Operations
export { mergeAnnotations, splitAnnotation, canMergeAnnotations, canSplitAnnotation } from './core/operations';

// Adapters
export { createOpenSeadragonAnnotator } from './adapters/openseadragon';

// Tools
export { PointTool, RectangleTool, PolygonTool, PushTool, SplitTool, ContourTool } from './tools';

// React Integration
export { AnnotaProvider, AnnotaViewer, Annotator } from './react';
export { useAnnotator, useAnnotations, useAnnotation, useSelection, useTool } from './react/hooks';

// Loaders
export { loadH5Annotations } from './loaders/h5';
export { loadPGMFile, annotationsToPGM } from './loaders/pgm';
```

## Next Steps

- **[Getting Started](/docs/getting-started)** - Install and create your first annotation app
- **[Core Concepts](/docs/guides/core-concepts)** - Understand annotations, layers, and state
- **[Performance Guide](/docs/guides/performance)** - Optimize for large datasets
- **[API Reference](/api)** - Complete API documentation
