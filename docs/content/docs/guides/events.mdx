# Event System

Annota provides a comprehensive event system to respond to annotation lifecycle changes.

## Event Types

Annota emits four core events:

```typescript
type AnnotatorEvent =
  | 'createAnnotation'   // When an annotation is created
  | 'updateAnnotation'   // When an annotation is modified
  | 'deleteAnnotation'   // When an annotation is deleted
  | 'selectionChanged';  // When selection changes
```

## Listening to Events

### Using the Annotator Instance

Access the annotator instance and register event handlers:

```tsx
import { useAnnotator } from 'annota';
import { useEffect } from 'react';

function AnnotationLogger() {
  const annotator = useAnnotator();

  useEffect(() => {
    if (!annotator) return;

    const handleCreate = (annotation) => {
      console.log('Annotation created:', annotation);
    };

    const handleUpdate = (annotation) => {
      console.log('Annotation updated:', annotation);
    };

    const handleDelete = (annotation) => {
      console.log('Annotation deleted:', annotation);
    };

    const handleSelection = ({ selected }) => {
      console.log('Selection changed:', selected);
    };

    // Register handlers
    annotator.on('createAnnotation', handleCreate);
    annotator.on('updateAnnotation', handleUpdate);
    annotator.on('deleteAnnotation', handleDelete);
    annotator.on('selectionChanged', handleSelection);

    // Cleanup
    return () => {
      annotator.off('createAnnotation', handleCreate);
      annotator.off('updateAnnotation', handleUpdate);
      annotator.off('deleteAnnotation', handleDelete);
      annotator.off('selectionChanged', handleSelection);
    };
  }, [annotator]);

  return null;
}
```

## createAnnotation Event

Fired when a new annotation is created.

### Event Data

```typescript
{
  id: string;
  shape: PointShape | RectangleShape | PolygonShape;
  properties?: Record<string, any>;
  style?: AnnotationStyle;
}
```

### Example: Auto-save New Annotations

```tsx
function AutoSave() {
  const annotator = useAnnotator();

  useEffect(() => {
    if (!annotator) return;

    const handleCreate = async (annotation) => {
      await fetch('/api/annotations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(annotation),
      });
      console.log('Saved annotation:', annotation.id);
    };

    annotator.on('createAnnotation', handleCreate);
    return () => annotator.off('createAnnotation', handleCreate);
  }, [annotator]);

  return null;
}
```

### Example: Count Annotations by Type

```tsx
function AnnotationCounter() {
  const [counts, setCounts] = useState({ point: 0, rectangle: 0, polygon: 0 });
  const annotator = useAnnotator();

  useEffect(() => {
    if (!annotator) return;

    const handleCreate = (annotation) => {
      setCounts(prev => ({
        ...prev,
        [annotation.shape.type]: prev[annotation.shape.type] + 1,
      }));
    };

    annotator.on('createAnnotation', handleCreate);
    return () => annotator.off('createAnnotation', handleCreate);
  }, [annotator]);

  return (
    <div>
      <div>Points: {counts.point}</div>
      <div>Rectangles: {counts.rectangle}</div>
      <div>Polygons: {counts.polygon}</div>
    </div>
  );
}
```

## updateAnnotation Event

Fired when an annotation is modified (properties, style, or shape).

### Event Data

The updated annotation object.

### Example: Track Changes

```tsx
function ChangeTracker() {
  const [changes, setChanges] = useState([]);
  const annotator = useAnnotator();

  useEffect(() => {
    if (!annotator) return;

    const handleUpdate = (annotation) => {
      setChanges(prev => [...prev, {
        id: annotation.id,
        timestamp: new Date(),
        type: 'update',
      }]);
    };

    annotator.on('updateAnnotation', handleUpdate);
    return () => annotator.off('updateAnnotation', handleUpdate);
  }, [annotator]);

  return (
    <div>
      <h3>Recent Changes</h3>
      {changes.map((change, i) => (
        <div key={i}>
          {change.type}: {change.id} at {change.timestamp.toLocaleTimeString()}
        </div>
      ))}
    </div>
  );
}
```

### Example: Sync Updates to Server

```tsx
function ServerSync() {
  const annotator = useAnnotator();

  useEffect(() => {
    if (!annotator) return;

    const handleUpdate = async (annotation) => {
      await fetch(`/api/annotations/${annotation.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(annotation),
      });
    };

    annotator.on('updateAnnotation', handleUpdate);
    return () => annotator.off('updateAnnotation', handleUpdate);
  }, [annotator]);

  return null;
}
```

## deleteAnnotation Event

Fired when an annotation is deleted.

### Event Data

The deleted annotation object.

### Example: Confirm Deletion

```tsx
function DeletionLogger() {
  const annotator = useAnnotator();

  useEffect(() => {
    if (!annotator) return;

    const handleDelete = (annotation) => {
      console.log(`Deleted annotation ${annotation.id} (${annotation.shape.type})`);

      // Optional: sync deletion to server
      fetch(`/api/annotations/${annotation.id}`, {
        method: 'DELETE',
      });
    };

    annotator.on('deleteAnnotation', handleDelete);
    return () => annotator.off('deleteAnnotation', handleDelete);
  }, [annotator]);

  return null;
}
```

### Example: Undo Support

```tsx
function UndoManager() {
  const [deletedAnnotations, setDeletedAnnotations] = useState([]);
  const annotator = useAnnotator();

  useEffect(() => {
    if (!annotator) return;

    const handleDelete = (annotation) => {
      setDeletedAnnotations(prev => [...prev, annotation]);
    };

    annotator.on('deleteAnnotation', handleDelete);
    return () => annotator.off('deleteAnnotation', handleDelete);
  }, [annotator]);

  const undo = () => {
    const lastDeleted = deletedAnnotations[deletedAnnotations.length - 1];
    if (lastDeleted && annotator) {
      annotator.addAnnotation(lastDeleted);
      setDeletedAnnotations(prev => prev.slice(0, -1));
    }
  };

  return (
    <button onClick={undo} disabled={deletedAnnotations.length === 0}>
      Undo Delete
    </button>
  );
}
```

## selectionChanged Event

Fired when the selection changes.

### Event Data

```typescript
{
  selected: string[];  // Array of selected annotation IDs
}
```

### Example: Show Selection Info

```tsx
function SelectionInfo() {
  const [selectedIds, setSelectedIds] = useState([]);
  const annotator = useAnnotator();

  useEffect(() => {
    if (!annotator) return;

    const handleSelection = ({ selected }) => {
      setSelectedIds(selected);
    };

    annotator.on('selectionChanged', handleSelection);
    return () => annotator.off('selectionChanged', handleSelection);
  }, [annotator]);

  return (
    <div>
      <h3>Selected Annotations</h3>
      <div>Count: {selectedIds.length}</div>
      <ul>
        {selectedIds.map(id => (
          <li key={id}>{id}</li>
        ))}
      </ul>
    </div>
  );
}
```

### Example: Bulk Operations

```tsx
function BulkOperations() {
  const [selectedIds, setSelectedIds] = useState([]);
  const annotator = useAnnotator();

  useEffect(() => {
    if (!annotator) return;

    const handleSelection = ({ selected }) => {
      setSelectedIds(selected);
    };

    annotator.on('selectionChanged', handleSelection);
    return () => annotator.off('selectionChanged', handleSelection);
  }, [annotator]);

  const deleteSelected = () => {
    selectedIds.forEach(id => annotator?.deleteAnnotation(id));
  };

  const changeColor = (color: string) => {
    selectedIds.forEach(id => {
      annotator?.updateAnnotation(id, {
        style: { fill: color },
      });
    });
  };

  return (
    <div>
      <button onClick={deleteSelected} disabled={selectedIds.length === 0}>
        Delete Selected ({selectedIds.length})
      </button>
      <button onClick={() => changeColor('#FF0000')}>Red</button>
      <button onClick={() => changeColor('#00FF00')}>Green</button>
    </div>
  );
}
```

## Emitting Custom Events

You can emit custom events programmatically:

```tsx
const annotator = useAnnotator();

// Emit an event
annotator?.emit('selectionChanged', { selected: ['ann-1', 'ann-2'] });
```

## Event Handler Patterns

### Debouncing Events

Avoid excessive event firing:

```tsx
import { useEffect, useRef } from 'react';
import { debounce } from 'lodash';

function DebouncedSync() {
  const annotator = useAnnotator();
  const debouncedSyncRef = useRef(
    debounce(async (annotation) => {
      await fetch(`/api/annotations/${annotation.id}`, {
        method: 'PATCH',
        body: JSON.stringify(annotation),
      });
    }, 500)
  );

  useEffect(() => {
    if (!annotator) return;

    const handleUpdate = (annotation) => {
      debouncedSyncRef.current(annotation);
    };

    annotator.on('updateAnnotation', handleUpdate);
    return () => annotator.off('updateAnnotation', handleUpdate);
  }, [annotator]);

  return null;
}
```

### Event Filtering

Filter events based on conditions:

```tsx
function TumorAnnotationLogger() {
  const annotator = useAnnotator();

  useEffect(() => {
    if (!annotator) return;

    const handleCreate = (annotation) => {
      // Only log tumor annotations
      if (annotation.properties?.type === 'tumor') {
        console.log('Tumor annotation created:', annotation.id);
      }
    };

    annotator.on('createAnnotation', handleCreate);
    return () => annotator.off('createAnnotation', handleCreate);
  }, [annotator]);

  return null;
}
```

### Combining Multiple Events

React to multiple events in a single component:

```tsx
function AnnotationMonitor() {
  const [stats, setStats] = useState({ created: 0, updated: 0, deleted: 0 });
  const annotator = useAnnotator();

  useEffect(() => {
    if (!annotator) return;

    const handlers = {
      create: () => setStats(prev => ({ ...prev, created: prev.created + 1 })),
      update: () => setStats(prev => ({ ...prev, updated: prev.updated + 1 })),
      delete: () => setStats(prev => ({ ...prev, deleted: prev.deleted + 1 })),
    };

    annotator.on('createAnnotation', handlers.create);
    annotator.on('updateAnnotation', handlers.update);
    annotator.on('deleteAnnotation', handlers.delete);

    return () => {
      annotator.off('createAnnotation', handlers.create);
      annotator.off('updateAnnotation', handlers.update);
      annotator.off('deleteAnnotation', handlers.delete);
    };
  }, [annotator]);

  return (
    <div>
      <div>Created: {stats.created}</div>
      <div>Updated: {stats.updated}</div>
      <div>Deleted: {stats.deleted}</div>
    </div>
  );
}
```

## Best Practices

### 1. Always Clean Up

Always remove event listeners in the cleanup function:

```tsx
useEffect(() => {
  if (!annotator) return;

  const handler = (data) => { /* ... */ };
  annotator.on('createAnnotation', handler);

  return () => {
    annotator.off('createAnnotation', handler);  // âœ… Cleanup
  };
}, [annotator]);
```

### 2. Handle Async Operations

Use async/await for server operations:

```tsx
const handleCreate = async (annotation) => {
  try {
    await fetch('/api/annotations', {
      method: 'POST',
      body: JSON.stringify(annotation),
    });
  } catch (error) {
    console.error('Failed to save annotation:', error);
  }
};
```

### 3. Error Handling

Wrap handlers in try/catch to prevent errors from breaking the app:

```tsx
const handleUpdate = (annotation) => {
  try {
    // Your logic here
  } catch (error) {
    console.error('Error handling update:', error);
  }
};
```

### 4. Use Stable References

For complex handlers, use useCallback or useRef to maintain stable references:

```tsx
const handleCreate = useCallback((annotation) => {
  // Handler logic
}, [/* dependencies */]);
```

## Next Steps

- [API Reference](/api/annotator) - Complete annotator API
- [Annotation Tools](/docs/guides/tools) - Learn about annotation tools
- [Examples](/docs/examples/event-handling) - See practical event handling examples
