# Data Loaders

Annota provides built-in loaders for importing annotations from various file formats.

## Overview

| Loader | Format | Use Case |
|--------|--------|----------|
| `loadMaskPolygons` | PNG/PGM masks | Instance segmentation masks from pathology models |
| `loadH5Masks` | HDF5 masks | Segmentation masks from analysis pipelines |
| `loadH5Coordinates` | HDF5 coordinates | Point annotations from detection algorithms |
| `loadJSON` | JSON | Standard annotation interchange |
| `loadPGM` | PGM masks | Legacy mask format |

## PNG/PGM Mask Loader

Load instance segmentation masks from PNG or PGM files and convert them to polygon annotations. This loader is specifically designed for pathology image analysis workflows where AI models output instance segmentation masks.

### Basic Usage

```tsx
import { loadMaskPolygons, useAnnotator } from 'annota';

function LoadMasks() {
  const annotator = useAnnotator();

  const handleLoad = async () => {
    const annotations = await loadMaskPolygons('/masks/instances.png', {
      color: '#FFFF00',
      fillOpacity: 0.3,
      strokeWidth: 2,
    });

    annotator?.addAnnotations(annotations);
  };

  return <button onClick={handleLoad}>Load Mask</button>;
}
```

### Expected File Format

#### 16-bit Grayscale PNG (Recommended)

For instance segmentation masks from pathology models:

- **Format**: 16-bit grayscale PNG
- **Color type**: Grayscale (no palette, no RGB)
- **Pixel values**:
  - `0` = background (ignored)
  - `1-65535` = unique instance IDs
- **Encoding**: Big-endian (standard PNG format)

**Example**: If your AI model detects 160 nuclei, the mask will have pixel values from 0 (background) to 160 (instance IDs).

```python
# Creating a 16-bit instance mask in Python
import numpy as np
from PIL import Image

# Create instance mask (640x640 with 160 instances)
mask = np.zeros((640, 640), dtype=np.uint16)
# ... assign instance IDs to pixels ...
mask[y1:y2, x1:x2] = 1  # Instance 1
mask[y3:y4, x3:x4] = 2  # Instance 2

# Save as 16-bit PNG
Image.fromarray(mask).save('instances.png')
```

#### PGM Format

Legacy grayscale format, similar structure to PNG:

- **Format**: PGM (Portable GrayMap)
- **Max value**: Typically 255 or 65535
- **Pixel values**: Same as PNG (0 = background, 1+ = instance IDs)

### How It Works

The loader uses OpenCV.js for contour detection:

1. **Decodes** the 16-bit PNG using UPNG.js (handles big-endian byte order)
2. **Extracts** unique instance IDs from pixel values
3. **Creates binary masks** for each instance separately
4. **Detects contours** using `cv.findContours()` with `RETR_EXTERNAL` mode
5. **Simplifies polygons** using `cv.approxPolyDP()` (0.5% tolerance)
6. **Keeps all contours** for fragmented instances (not just the largest)

### Options

```typescript
interface MaskLoaderOptions {
  color?: string;          // Polygon color (default: '#FFFF00')
  fillOpacity?: number;    // Fill opacity (default: 0.3)
  strokeWidth?: number;    // Stroke width (default: 2)
  layer?: string;          // Layer name (default: 'masks')
}
```

### Complete Example

```tsx
import { loadMaskPolygons, useAnnotator } from 'annota';
import { useState } from 'react';

function MaskImporter() {
  const [loading, setLoading] = useState(false);
  const [count, setCount] = useState(0);
  const annotator = useAnnotator();

  const loadMask = async (imageId: string) => {
    setLoading(true);
    try {
      const annotations = await loadMaskPolygons(
        `/masks/${imageId}.png`,
        {
          color: '#FFFF00',
          fillOpacity: 0.3,
          strokeWidth: 2,
        }
      );

      annotator?.addAnnotations(annotations);
      setCount(annotations.length);
    } catch (error) {
      console.error('Failed to load mask:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <button onClick={() => loadMask('slide_001')} disabled={loading}>
        {loading ? 'Loading...' : 'Load Nuclei Mask'}
      </button>
      {count > 0 && <p>Loaded {count} instances</p>}
    </div>
  );
}
```

### Performance Considerations

- **Polygon simplification**: Reduces vertex count by ~90% while maintaining shape accuracy
- **Fragmented instances**: Each disconnected region becomes a separate annotation with ID `mask-{instanceId}-{contourIndex}`
- **Minimum area**: Contours smaller than 100 pixels are filtered out as noise
- **OpenCV.js loading**: First use may take 10-30 seconds to download OpenCV WebAssembly (~8MB)

### Troubleshooting

**No polygons extracted:**
- Verify PNG is 16-bit grayscale (not RGB or 8-bit)
- Check pixel values are non-zero (0 = background)
- Ensure OpenCV.js loaded successfully (check browser console)

**Incorrect shapes:**
- Verify mask uses pixel values as instance IDs (not RGB encoding)
- Check byte order is big-endian (standard PNG format)

**Memory issues:**
- For very large masks (>4000x4000), consider tiling or downsampling
- Each polygon uses memory proportional to vertex count

## H5 Mask Loader

Load segmentation masks from HDF5 files and convert them to polygon annotations.

### Basic Usage

```tsx
import { loadH5Masks, useAnnotator } from 'annota';

function LoadMasks() {
  const annotator = useAnnotator();

  const handleLoad = async () => {
    const annotations = await loadH5Masks('/annotations/masks.h5', {
      color: '#FF0000',
      fillOpacity: 0.3,
    });

    annotator?.addAnnotations(annotations);
  };

  return <button onClick={handleLoad}>Load H5 Masks</button>;
}
```

### Options

```typescript
interface H5MaskLoaderOptions {
  color?: string;          // Annotation color (default: '#00FF00')
  fillOpacity?: number;    // Fill opacity (default: 0.3)
  strokeWidth?: number;    // Stroke width (default: 2)
  dataset?: string;        // Dataset path in H5 file (auto-detected if not specified)
  properties?: Record<string, any>;  // Custom properties for annotations
}
```

### Dataset Detection

The loader automatically detects the mask dataset. If your H5 file has a non-standard structure, specify the dataset path:

```tsx
const annotations = await loadH5Masks('/annotations/masks.h5', {
  dataset: '/masks/nuclei',  // Explicit dataset path
});
```

### Error Handling

```tsx
async function loadMasksWithErrorHandling() {
  try {
    const annotations = await loadH5Masks('/annotations/masks.h5');
    console.log(`Loaded ${annotations.length} annotations`);
    return annotations;
  } catch (error) {
    console.error('Failed to load H5 masks:', error);
    // Error includes available datasets if detection fails
    return [];
  }
}
```

## H5 Coordinate Loader

Load point coordinates from HDF5 files (e.g., cell detections from AI models).

### Basic Usage

```tsx
import { loadH5Coordinates } from 'annota';

async function loadCells() {
  const annotations = await loadH5Coordinates('/annotations/cells.h5', {
    color: '#00FF00',
    fillOpacity: 0.8,
  });

  return annotations;
}
```

### Options

```typescript
interface H5CoordinateLoaderOptions {
  color?: string;          // Point color (default: '#00FF00')
  fillOpacity?: number;    // Fill opacity (default: 0.8)
  strokeWidth?: number;    // Stroke width (default: 2)
  properties?: Record<string, any>;  // Custom properties
}
```

### Expected Format

The H5 file should contain a `coordinates` dataset with shape `[N, 2]`:

```
coordinates/
  shape: [1000, 2]  # 1000 points with (x, y) coordinates
  data: [
    [x0, y0],
    [x1, y1],
    ...
  ]
```

### Example: Loading Multiple Categories

```tsx
async function loadMultipleCategoriesannot() {
  const [positiveAnnotations, negativeAnnotations] = await Promise.all([
    loadH5Coordinates('/annotations/positive.h5', {
      color: '#00FF00',
      properties: { category: 'positive' },
    }),
    loadH5Coordinates('/annotations/negative.h5', {
      color: '#FF0000',
      properties: { category: 'negative' },
    }),
  ]);

  return [...positiveAnnotations, ...negativeAnnotations];
}
```

## JSON Loader

Load annotations from JSON files.

### Format

```json
[
  {
    "id": "ann-1",
    "shape": {
      "type": "point",
      "point": { "x": 100, "y": 200 },
      "bounds": { "minX": 100, "minY": 200, "maxX": 100, "maxY": 200 }
    },
    "properties": {
      "type": "cell"
    },
    "style": {
      "fill": "#FF0000",
      "fillOpacity": 0.8
    }
  }
]
```

### Loading

```tsx
async function loadJSONAnnotations(path: string) {
  const response = await fetch(path);
  const annotations = await response.json();
  return annotations;
}
```

## PGM Loader

Load legacy PGM mask files.

### Basic Usage

```tsx
import { loadPGMMasks } from 'annota';

const annotations = await loadPGMMasks('/annotations/mask.pgm', {
  color: '#0000FF',
  fillOpacity: 0.3,
});
```

## Best Practices

### 1. Show Loading State

```tsx
function MaskLoader() {
  const [loading, setLoading] = useState(false);
  const annotator = useAnnotator();

  const handleLoad = async () => {
    setLoading(true);
    try {
      const annotations = await loadH5Masks('/annotations/masks.h5');
      annotator?.addAnnotations(annotations);
    } finally {
      setLoading(false);
    }
  };

  return (
    <button onClick={handleLoad} disabled={loading}>
      {loading ? 'Loading...' : 'Load Masks'}
    </button>
  );
}
```

### 2. Layer Organization

Assign loaded annotations to specific layers:

```tsx
const annotations = await loadH5Masks('/annotations/masks.h5', {
  properties: {
    layer: 'imported-masks',  // Assign to specific layer
    source: 'h5',
  },
});
```

### 3. Batch Loading

Load multiple files efficiently:

```tsx
async function loadAllAnnotations(files: string[]) {
  const results = await Promise.all(
    files.map(file => loadH5Masks(file))
  );

  return results.flat();
}
```

### 4. Progress Tracking

For large files, track loading progress:

```tsx
function ProgressLoader({ files }: { files: string[] }) {
  const [progress, setProgress] = useState(0);
  const annotator = useAnnotator();

  const loadAll = async () => {
    for (let i = 0; i < files.length; i++) {
      const annotations = await loadH5Masks(files[i]);
      annotator?.addAnnotations(annotations);
      setProgress(((i + 1) / files.length) * 100);
    }
  };

  return (
    <div>
      <button onClick={loadAll}>Load All</button>
      <div>Progress: {progress.toFixed(0)}%</div>
    </div>
  );
}
```

## Next Steps

- [API Reference](/api) - Complete loader API documentation
- [Examples](/docs/examples/h5-loading) - See practical loading examples
- [Events](/docs/guides/events) - Handle post-load events
