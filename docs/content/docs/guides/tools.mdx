# Annotation Tools

Annota provides a comprehensive set of tools for creating and editing annotations.

## Overview

Tools enable users to interact with the image and create annotations. Each tool implements a specific interaction pattern:

| Tool              | Purpose                     | Interaction                            |
| ----------------- | --------------------------- | -------------------------------------- |
| **PointTool**     | Create point markers        | Single click                           |
| **RectangleTool** | Draw rectangles             | Click and drag                         |
| **PolygonTool**   | Draw polygons               | Click vertices, double-click to finish |
| **PushTool**      | Edit polygon vertices       | Click and drag to push/pull vertices   |
| **ContourTool**   | Extract contours from masks | Click to detect contours               |
| **SplitTool**     | Cut annotations into pieces | Click start point, click end point     |

## Using Tools

### Basic Usage

Activate a tool using the `useTool` hook:

```tsx
import { useTool, PointTool } from "annota";

function MyComponent({ viewer }) {
  const pointTool = new PointTool();

  useTool({
    viewer,
    handler: pointTool,
    enabled: true,
  });

  return null;
}
```

### Tool Switching

Allow users to switch between tools:

```tsx
import { useTool, PointTool, RectangleTool, PolygonTool } from "annota";
import { useState } from "react";

function ToolController({ viewer }) {
  const [activeTool, setActiveTool] = useState("point");

  const tools = {
    point: new PointTool(),
    rectangle: new RectangleTool(),
    polygon: new PolygonTool(),
  };

  useTool({
    viewer,
    handler: activeTool === "pan" ? null : tools[activeTool],
    enabled: activeTool !== "pan",
  });

  return (
    <div>
      <button onClick={() => setActiveTool("pan")}>Pan</button>
      <button onClick={() => setActiveTool("point")}>Point</button>
      <button onClick={() => setActiveTool("rectangle")}>Rectangle</button>
      <button onClick={() => setActiveTool("polygon")}>Polygon</button>
    </div>
  );
}
```

## Point Tool

Create point annotations with a single click.

### Basic Usage

```tsx
import { PointTool } from "annota";

const pointTool = new PointTool();
```

### Configuration

```tsx
const pointTool = new PointTool({
  style: {
    fill: "#FF0000",
    fillOpacity: 0.8,
    stroke: "#FFFFFF",
    strokeWidth: 2,
  },
});
```

### Use Cases

- Cell counting
- Nuclei detection
- Marking points of interest
- Landmarks for registration

## Rectangle Tool

Draw rectangular regions by clicking and dragging.

### Basic Usage

```tsx
import { RectangleTool } from "annota";

const rectangleTool = new RectangleTool();
```

### Configuration

```tsx
const rectangleTool = new RectangleTool({
  style: {
    fill: "#00FF00",
    fillOpacity: 0.3,
    stroke: "#00FF00",
    strokeWidth: 2,
  },
});
```

### Interaction

1. **Click** to start the rectangle
2. **Drag** to define the size
3. **Release** to finish

### Use Cases

- Region of interest (ROI) selection
- Bounding boxes for detection
- Quick area selection
- Crop regions

## Polygon Tool

Draw polygons by clicking to add vertices.

### Basic Usage

```tsx
import { PolygonTool } from "annota";

const polygonTool = new PolygonTool();
```

### Configuration

```tsx
const polygonTool = new PolygonTool({
  style: {
    fill: "#0000FF",
    fillOpacity: 0.3,
    stroke: "#0000FF",
    strokeWidth: 2,
  },
});
```

### Interaction

1. **Click** to add vertices
2. **Move mouse** to preview next segment
3. **Double-click** or **press Enter** to finish
4. **Press Escape** to cancel

### Use Cases

- Tracing tumor boundaries
- Segmentation masks
- Complex region outlines
- Freeform annotations

## Push Tool

Edit polygon vertices by pushing and pulling.

### Basic Usage

```tsx
import { PushTool } from "annota";

const pushTool = new PushTool({
  radius: 30, // Influence radius in pixels
});
```

### Configuration

```tsx
const pushTool = new PushTool({
  radius: 50, // Larger influence radius
  strength: 1.0, // Strength of the push effect (0-1)
  showCursor: true, // Show the cursor indicator
});
```

### Interaction

1. **Click and drag** on or near polygon edges
2. Vertices within the radius are pushed
3. Effect falls off with distance from cursor

### Use Cases

- Refining polygon boundaries
- Adjusting segmentation masks
- Fine-tuning contours
- Natural shape editing

## Contour Tool

Automatically detect contours from underlying image data.

### Basic Usage

```tsx
import { ContourTool } from "annota";

const contourTool = new ContourTool({
  threshold: 128, // Pixel value threshold
});
```

### Configuration

```tsx
const contourTool = new ContourTool({
  threshold: 128, // Threshold for binary mask
  minArea: 100, // Minimum contour area (optional)
  maxContours: 1000, // Maximum number of contours (optional)
  style: {
    fill: "#FFFF00",
    fillOpacity: 0.3,
  },
});
```

### Interaction

1. **Click** on the image where you want to detect contours
2. Contours are automatically extracted from the region
3. Each contour becomes a polygon annotation

### Use Cases

- Converting segmentation masks to polygons
- Extracting cell boundaries from stained images
- Automatic region detection
- Batch annotation from masks

### Requirements

The Contour Tool requires OpenCV.js. Install it:

```bash
npm install @techstark/opencv-js
```

Then enable it in your app:

```tsx
import { loadOpenCV } from "annota";

// Load OpenCV before using ContourTool
await loadOpenCV();

const contourTool = new ContourTool({ threshold: 128 });
```

## Split Tool

Cut annotations into multiple pieces with a simple line.

### Basic Usage

```tsx
import { SplitTool } from "annota";

const splitTool = new SplitTool();
```

### Workflow

1. **Select an annotation** (before or during tool activation)
2. **Activate the split tool**
3. **Click** to set the start point of the split line
4. **Move mouse** - an orange line preview follows the cursor
5. **Click** to set the end point and execute the split
6. Tool automatically exits after split completes

### Interaction

- **First click**: Sets the start point of the split line
- **Mouse move**: Updates the orange preview line
- **Second click**: Executes the split operation
- **Escape**: Cancels the split operation
- **Enter**: Completes split with current line (alternative to clicking)

### Configuration

```tsx
const splitTool = new SplitTool({
  preventDefaultAction: true, // Prevent panning during split
  checkAnnotationHits: true,  // Enable annotation hit detection
});
```

### Visual Feedback

The split tool provides clear visual feedback:
- **Orange line** (color: `#ff6b00`) shows where the split will occur
- Line follows mouse movement in real-time
- Line width: 3 pixels for visibility

### Use Cases

- Dividing large tumor regions into smaller sections
- Separating overlapping annotations
- Creating training data from large masks
- Refining segmentation boundaries
- Splitting merged tissue regions

### Supported Annotation Types

The split tool works with:
- Polygons
- Rectangles (converted to polygons)
- MultiPolygons
- Closed freehand shapes

### Requirements

- Annotation must be selected before splitting
- Split line must intersect the annotation
- Split line must have at least 2 points
- Annotation must be polygon-compatible

### Example

```tsx
import { SplitTool, useTool } from "annota";
import { useState } from "react";

function SplitToolController({ viewer }) {
  const [splitTool] = useState(() => new SplitTool());
  const [enabled, setEnabled] = useState(false);

  useTool({
    viewer,
    handler: enabled ? splitTool : null,
    enabled,
  });

  return (
    <button onClick={() => setEnabled(!enabled)}>
      {enabled ? "Exit Split Mode" : "Split Tool"}
    </button>
  );
}
```

## Merge Operation

Combine multiple selected annotations into a single annotation using polygon union.

### Basic Usage

Unlike tools, merge is performed via the annotator instance:

```tsx
import { useAnnotator } from "annota";

function MergeButton() {
  const annotator = useAnnotator();

  const handleMerge = () => {
    // Merge all currently selected annotations
    const merged = annotator.mergeSelected();
    if (merged) {
      console.log("Successfully merged annotations");
    }
  };

  return <button onClick={handleMerge}>Merge Selected</button>;
}
```

### How It Works

The merge operation:
1. Takes all selected annotations
2. Converts them to polygon format
3. Computes the polygon union using `polygon-clipping`
4. Creates a single new annotation from the result
5. Always returns a single polygon (even if inputs are disjoint)
6. Replaces the original annotations

### Merging Disjoint Polygons

When merging annotations that don't touch:
- The result is the **convex hull** of all polygons
- This creates a single polygon that bounds all inputs
- Properties and style are inherited from the first annotation

### Configuration

```tsx
// Select multiple annotations first
annotator.setSelected([id1, id2, id3]);

// Then merge them
const merged = annotator.mergeSelected();
```

### Supported Annotation Types

The merge operation works with:
- Polygons
- Rectangles (converted to polygons)
- MultiPolygons
- Closed freehand shapes

**Note**: All selected annotations must be polygon-compatible.

### Programmatic Usage

```tsx
import { mergeAnnotations, canMergeAnnotations } from "annota";

// Check if annotations can be merged
const annotations = [annotation1, annotation2, annotation3];
if (canMergeAnnotations(annotations)) {
  // Perform the merge
  const merged = mergeAnnotations(annotations);

  if (merged) {
    // Add to store
    annotator.addAnnotation(merged);
    // Remove originals
    annotations.forEach(ann => annotator.deleteAnnotation(ann.id));
  }
}
```

### Use Cases

- Combining multiple regions into a single annotation
- Merging adjacent tissue sections
- Consolidating overlapping masks
- Creating unified ROIs from multiple selections
- Simplifying annotation sets

### Undo/Redo Support

Both split and merge operations support undo/redo through the history system:

```tsx
// After splitting or merging
annotator.undo(); // Reverts the operation
annotator.redo(); // Reapplies the operation
```

## Tool Options

All tools support these common options:

### Style

Default style for created annotations:

```tsx
const tool = new PointTool({
  style: {
    fill: "#FF0000",
    fillOpacity: 0.8,
    stroke: "#FFFFFF",
    strokeWidth: 2,
    strokeOpacity: 1.0,
  },
});
```

### Layer

Assign created annotations to a specific layer:

```tsx
const tool = new PointTool({
  layer: "tumor", // Annotations will be created on the 'tumor' layer
});
```

### Properties

Add custom properties to created annotations:

```tsx
const tool = new PointTool({
  properties: {
    type: "cell",
    confidence: 1.0,
  },
});
```

## Tool Lifecycle

### Enabling/Disabling

Control when a tool is active:

```tsx
const [enabled, setEnabled] = useState(true);

useTool({
  viewer,
  handler: pointTool,
  enabled, // Tool only active when true
});
```

### Cleanup

Tools automatically clean up when unmounted. No manual cleanup required.

### Tool State

Some tools maintain internal state (e.g., polygon vertices being drawn). This state is automatically reset when the tool is disabled or changed.

## Advanced Usage

### Custom Tool Cursors

Display custom cursors when tools are active:

```tsx
import { usePushToolCursor } from "annota";

function PushToolController({ viewer, radius }) {
  const pushTool = new PushTool({ radius });

  useTool({ viewer, handler: pushTool, enabled: true });
  usePushToolCursor({ viewer, radius }); // Show radius cursor

  return null;
}
```

### Tool Events

Listen to tool events:

```tsx
const tool = new PointTool();

tool.on("start", () => {
  console.log("Tool activated");
});

tool.on("create", (annotation) => {
  console.log("Annotation created:", annotation);
});

tool.on("cancel", () => {
  console.log("Tool cancelled");
});
```

### Conditional Tool Behavior

Change tool behavior based on conditions:

```tsx
function SmartTool({ viewer, mode }) {
  const tool =
    mode === "tumor"
      ? new PolygonTool({ style: { fill: "#FF0000" }, layer: "tumor" })
      : new PolygonTool({ style: { fill: "#00FF00" }, layer: "healthy" });

  useTool({ viewer, handler: tool, enabled: true });

  return null;
}
```

## Best Practices

### 1. Reuse Tool Instances

Create tool instances once, not on every render:

```tsx
// ✅ Good
const [tools] = useState({
  point: new PointTool(),
  rectangle: new RectangleTool(),
});

// ❌ Bad
const tools = {
  point: new PointTool(), // Creates new instance every render
  rectangle: new RectangleTool(),
};
```

### 2. Provide Visual Feedback

Show which tool is active:

```tsx
<button
  onClick={() => setTool("point")}
  style={{ fontWeight: tool === "point" ? "bold" : "normal" }}
>
  Point Tool
</button>
```

### 3. Allow Deactivation

Always provide a way to disable tools (e.g., "Pan" mode):

```tsx
<button onClick={() => setTool("pan")}>Pan Mode</button>
```

### 4. Keyboard Shortcuts

Add keyboard shortcuts for common tools:

```tsx
useEffect(() => {
  const handleKeyPress = (e: KeyboardEvent) => {
    if (e.key === "p") setTool("point");
    if (e.key === "r") setTool("rectangle");
    if (e.key === "g") setTool("polygon");
    if (e.key === "v") setTool("pan");
  };

  window.addEventListener("keydown", handleKeyPress);
  return () => window.removeEventListener("keydown", handleKeyPress);
}, []);
```

## Next Steps

- [Custom Tools](/docs/guides/custom-tools) - Build your own annotation tools
- [Events](/docs/guides/events) - Respond to annotation changes
- [Styling](/docs/guides/styling) - Customize annotation appearance
- [API](/api/tools-api) - Complete tool API documentation
